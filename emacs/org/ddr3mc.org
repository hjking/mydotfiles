

** DDR2

*** Write
**** Write Interrupt
    1. BL=8的Write才能被中断。BL=4不可以
    2. 只有Write才能中断BL=8的Write
    3. 后一个Write只有在前一个Write之后2个时钟发生
    4. 任何Bank的Write都可以被中断
    5. Write with Auto Precharge不能被中断
    6. Write能被另一个Write with Auto Precharge中断

**** Write Mask

*** Precharge
    预充电或者关闭一个已经激活的Bank
    触发：/CS，/RAS，/WE low；/CAS high
**** Read后Precharge
     最小时间间隔：AL + BL/2 + max(RTP,2) - 2 时钟
     tRTP：BL=4：Read后AL到Precharge
           BL=8：Read后AL+2到Precharge
**** Write后Precharge
     最小时间间隔：WL + BL/2 + tWR
     tWR：write recovery time.最后一个burst数据到Precharge

*** Auto Precharge (AP)
    作用：在已激活的Bank中打开一个新Row

    在发出的Read或者Write命令中，若A10控制Auto Precharge在Read或Write结束时是否
    启动。A10为HIGH，Auto Precharge激活。

    在Read后激活Auto Precharge时，Auto Precharge在最后一个burst数据之前的CL个时
    钟的上升沿激活。

    在Write后激活Auto Precharge时，只有在确保最后一个数据已保存好了之后才能激活。

*** Refresh (REF)
    触发:/CS, /RAS, /CAS are LOW; /WE is HIGH
    所有的Bank必须都已激活，并处于idle至少tRP时间。
    Refresh命令执行之后，所有的Bank处于idle状态。
    Refresh命令至下个Activate或者Refresh命令之间的延迟为至少tRFC

*** Self Refresh
    作用：不需要外部时钟，就可保持SDRAM中的数据
    触发：/CS，/RAS，/CAS，CKE are LOW; /WE is HIGH；ODT必须已关闭。

    Self Refresh一旦触发，CKE必须保持为LOW。
    DLL在Auto Refresh启动后自动失效；结束后自动启动。

    一旦启动，至少保持tCKE时间。

    Self Refresh启动后一个时钟，用户可以改变或者停止外部时钟；但在Self Refresh结
    束之前，外部时钟必须已启动并保持稳定。

    退出Self Refresh的流程(SRX)：
        在CKE拉高之前，外部时钟保持稳定；
        SRX启动后，至少tXSNR之后才能启动其他有效命令；
        在SRX启动后的tXSRD期间，CKE必须保持为高；
        在SRX启动后的tXSRD期间的每个时钟上升沿，发NOP或者DES命令；
        tXSRD期间确保ODT已关闭。

*** Power Down

*** No operation
    作用：在SDRAM空闲或者等待状态时防止其他不期望的命令被执行。
    触发：/CS is LOW，/RAS，/CAS，/WE are HIGH

*** Deselect
    作用：与No Operation相同
    触发：/CS is HIGH，其他忽略

*** ODT
    (On-die Termination，片内终结器)是内建核心的终结电阻器。
    使用DDR SDRAM的主板上面为了防止数据线终端反射信号需要大量的终结电阻，它大大
    增加了主板的制造成本。实际上，不同的内存模组对终结电路的要求是不一样的，终结
    电阻的大小决定了数据线的信号比和反射率。因此主板上的终结电阻并不能非常好地匹
    配内存模组，还会在一定程度上影响信号品质。DDRII内建了终结电阻器，为DDRII带
    来了两个好处，一个是去掉了主板上的终结电阻器使主板的成本降低，也使PCB板的设
    计更加容易。第二个好处是终结电阻器可以和内存颗粒的"特性"相符，使DRAM处于最佳
    状态。

    在Active和STANDBY时有效
    SELF REFRESH时不支持

    在tMODmin，tMODmax期间更新Rtt，CKE保持为高
    ODT 保持为低

*** Bank Activate
    触发：/CAS，/WE are HIGH，/CS，/RAS are LOW
    BA0-BA2:  BANK Address
    A0-A15:   ROW Address
    一旦某一个Bank已激活，在另一BANK Activate命令触发之前，需Precharge

** DDR3

*** ODT
**** 同步ODT
     DLL on and locked
         Any bank active with CKE high
         refresh with CKE high
         Idle mode with CKE high
         Active power down mode
         precharge power down mode
     RTT 在ODT为HIGH后保持ODTLon个时钟，在ODT为LOW后保持ODTLoff个时钟
     ODTLon = WL  - 2 = CWL +　AL　－　２；
     ODTLoff = WL - 2　＝　CWL　＋　AL　－　２；

     一旦ODT为HIGH，至少保持ODTH4时钟
     有Write命令时，至少保持ODTH4（BL=4）或者ODTH8（BL=8）
     从ODT开始为HIGH至开始变LOW或者ODT为HIGH，并Write至ODT开始变LOW

**** 动态ODT
     由MR2的A9或者A10设置
     RTT值：RTT_NOM和RTT_WR
     RTT_Nom：MR1的A[9,6,2]
     RTT_WR：MR2的A[10,9]

     在没有Write时：RTT_Nom被启用
     有Write时：Write命令之后过ODTLcnw，RTT_WR被选择
               Write命令之后过ODTLcwn8或者ODTLcwn4，RTT_Nom被选择

     ODTLon  = WL - 2; 从ODT拉高至RTT开始改变的延迟
     ODTLoff = WL - 2; 从ODT拉低至RTT开始改变的延迟
     ODTLcnw = WL - 2; 从ODT拉高后至RTT从 RTT_Nom 变 RTT_WR的延迟
     ODTLcwn4 = 4 + ODTLoff; 从ODT拉高到RTT从 RTT_WR 改变至 RTT_Nom(BL=4)的延迟
     ODTLcwn8 = 6 + ODTLoff; 从ODT拉高到RTT从 RTT_WR 改变至 RTT_Nom(BL=8)的延迟
     ODTH4 = 4; ODT拉高后或者Write命令之后，ODT保持为HIGH的最少时间
     ODTH8 = 6；Write命令之后，ODT保持为HIGH的最少时间（BL=8)
     tADC: min = 0.3tCK RTT change skew
           max = 0.7tCK
**** 异步ODT
     在DLL on模式下，异步ODT被启用
     DLL暂时被停用


